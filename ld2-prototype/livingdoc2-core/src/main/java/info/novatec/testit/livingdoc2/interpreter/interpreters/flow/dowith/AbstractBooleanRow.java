package info.novatec.testit.livingdoc2.interpreter.interpreters.flow.dowith;

import java.util.List;

import info.novatec.testit.livingdoc2.call.Call;
import info.novatec.testit.livingdoc2.executables.ValueCell;
import info.novatec.testit.livingdoc2.executables.ValueRow;
import info.novatec.testit.livingdoc2.interpreter.interpreters.flow.AbstractRowType;


/**
 * @author Sebastian Letzel
 *         <p/>
 *         Abstract class for {@link info.novatec.testit.livingdoc2.api.interpreter.RowType}s which request a {@link
 *         Boolean}
 *         as {@link info.novatec.testit.livingdoc2.api.executionresult.ExecutionResult}
 */
public abstract class AbstractBooleanRow extends AbstractRowType {

    protected AbstractBooleanRow(ValueRow row) {
        super(row);
    }

    /**
     * Generates the needed values for the {@link info.novatec.testit.livingdoc2.call.builder.CallBuilder}.
     *
     * @return the {@link Call} from implementations of the abstract class {@code buildCall}
     */
    @Override
    public Call createCall() {
        ValueCell indicatorCell = valueRow.getFirstCell();
        List<ValueCell> keywordCells = keywordCells();
        List<ValueCell> argCells = argCellsWithoutRowIndicator();

        String methodName = buildMethodName(keywordCells);
        List<String> args = buildArgList(argCells);

        return buildCall(indicatorCell, methodName, args);
    }

    /**
     * @param indicatorCell {@link ValueCell} containing the {@link info.novatec.testit.livingdoc2.api.interpreter.RowType}
     * indicator.
     * @param methodName generated method name from the {@code keywordCells}
     * @param args arguments for the called method
     * @return a call generated by a subclass
     */
    protected abstract Call buildCall(ValueCell indicatorCell, String methodName, List<String> args);
}
